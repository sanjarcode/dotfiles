function custom_prompt()
{
    export GIT_PS1_SHOWDIRTYSTATE=1
    PS1='%B%F{green}sanjar%f%b$%F{red} %c%f '

    # if [[ "${USERNAME}" == "muhammadsanjar"]] then
    #     PS1='%B%F{green}sanjar%f%b$%F{red}%~%f '
    # else
    #     # use $USERNAME
    #     PS1='%B%F{green}%n%f%b$%F{red}%~%f '
    # fi
}

# gitify prompt, taken from the Udacity Git course
function gitify_prompt() {
    red="\[\033[38;5;203m\]"
    green="\[\033[38;05;38m\]"
    blue="\[\033[0;34m\]"
    reset="\[\033[0m\]"

    export GIT_PS1_SHOWDIRTYSTATE=1

    # '\u' adds the name of the current user to the prompt
    # '\$(__git_ps1)' adds git-related stuff
    # '\W' adds the name of the current directory
    export PS1="$red\u$green\ $(__git_ps1)$blue \W
$ $reset"

    # Changes colors for tty consoles
    if [ "$TERM" = "xterm-256color" ]; then
        echo -en "\e]P0232323" #black
        echo -en "\e]P82B2B2B" #darkgrey
        echo -en "\e]P1D75F5F" #darkred
        echo -en "\e]P9E33636" #red
        echo -en "\e]P287AF5F" #darkgreen
        echo -en "\e]PA98E34D" #green
        echo -en "\e]P3D7AF87" #brown
        echo -en "\e]PBFFD75F" #yellow
        echo -en "\e]P48787AF" #darkblue
        echo -en "\e]PC7373C9" #blue
        echo -en "\e]P5BD53A5" #darkmagenta
        echo -en "\e]PDD633B2" #magenta
        echo -en "\e]P65FAFAF" #darkcyan
        echo -en "\e]PE44C9C9" #cyan
        echo -en "\e]P7E5E5E5" #lightgrey
        echo -en "\e]PFFFFFFF" #white
        clear                  #for background artifacting
    fi
}

# To use the Heroku CLI's autocomplete --
#   Via homebrew's shell completion:
#     1) Follow homebrew's install instructions https://docs.brew.sh/Shell-Completion
#         NOTE: For zsh, as the instructions mention, be sure compinit is autoloaded
#               and called, either explicitly or via a framework like oh-my-zsh.
#     2) Then run
#       $ heroku autocomplete --refresh-cache
#   OR
#   Use our standalone setup:
#     1) Run and follow the install steps:
#       $ heroku autocomplete

# git
alias gco="git checkout"
alias ga="git add"
alias gunadd="git restore --staged" # Unstage path1 path2...
alias gcan="git commit --amend --no-edit"
alias gcm="git commit -m"
alias gst="git status"

# gh - GitHub CLI
alias ghcc='gh browse $(git rev-parse HEAD) -cn | tr -d "\n"' # get "commit" link instead of "tree" link. 
# See: https://github.com/cli/cli/issues/6926. Also using single quotes here.

# print (-s option) or navigate to Git repo root, current location or specified one
function groot {
    local show=
    local path=

    # Parse command line options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s)
                show=true
                shift
                ;;
            *)
                path="$1"
                shift
                ;;
        esac
    done

    # If no path is specified, use the current directory
    if [[ -z "$path" ]]; then
        path="."
    fi

    # Get the Git root directory and either change to it or print it
    local dir="$(cd "$path" && git rev-parse --show-toplevel 2>/dev/null)"
    if [[ -n "$dir" ]]; then
        dir="$(echo "$dir" | tr -d '\n')"
        if [[ -n "$show" ]]; then
            echo "$dir"
        else
            cd "$dir" || return
        fi
    else
        echo "Not inside a Git repository" >&2
        return 1
    fi
}

# print random human-friendly name
function namegen { 
    jsCode=$(cat <<-ENDJS
        const {
            uniqueNamesGenerator,
            adjectives,
            colors,
            animals
        } = require('unique-names-generator');

        const output = uniqueNamesGenerator({
            dictionaries: [adjectives, colors, animals],
            separator: '-'
        });

        console.log(output);
ENDJS
)
    node -e "$jsCode"

    # npm package - https://www.npmjs.com/package/unique-names-generator#user-content-usage
    # multiline bash - "here document" (chatGPT) - https://chat.openai.com/chat/21ad89f6-231f-4f92-8256-52c0f652fdcb
    # node -e "some js code" option is available
}

# kill process at port
# Usage: `portkill 3000`
function portkill() {
    fuser -k "$1/tcp"
}