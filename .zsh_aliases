#!/usr/bin/env sh

# CUSTOM Aliases #####################

#ls
# alias l='ls -lah --color'
# alias ls='ls --color'

# git
alias g='git'
alias gco="git checkout"
alias ga="git add"
alias gunadd="git restore --staged" # Unstage path1 path2...
alias gcan="git commit --amend --no-edit"
alias gcm="git commit -m"
function gcmp() { # git commit and push
    gcm "$@"
    git push
}
alias gst="git status"
alias gpp="git push"
alias gpl="git pull"
function gplo() {
    # `git pull other` branch
    # for hands free other-than-current-branch-update, see https://stackoverflow.com/a/45622872
    # Assumption: remote and local branches have same name
    # Todo, figure out remote branch name even if different and pull, so command always succeeds
    local_branch="$1"
    remote_branch="origin/$1"

    if [[ "$(git rev-parse --abbrev-ref $remote_branch)" == "origin/$local_branch" ]]; then
        # Perform the pull operation
        git fetch -u origin "$local_branch":"$local_branch"
    else
        echo "Error: Remote branch '$remote_branch' doesn't match local branch '$local_branch'"
        echo "No action performed."
    fi
}
# gh - GitHub CLI
# get "commit" link instead of "tree" link.
alias ghcc='gh browse --no-browser $(git rev-parse HEAD) --repo $(git remote get-url origin | sed -e "s#.*github.com[:/]\(.*\)\.git#\1#") | tr -d "\n"'
# See: https://github.com/cli/cli/issues/7502
# Note: the --repo option is needed since `gh` doesn't work well when the repo is part of a fork chain
# the `git remote get-url` with `sed` is needed to get the value for `--repo`. `gh` doesn't have a way to get the repo name, yes, weird.
# the `git remote get-url` with `sed` works in all cases - cloned with git (SSH, HTTPS) or with `gh repo clone`

# CUSTOM Functions #####################

poweroff() {
  osascript -e 'tell app "System Events" to shut down'
}

# print (-s option) or navigate to Git repo root, current location or specified one
function groot {
    local show=
    local path=

    # Parse command line options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s)
                show=true
                shift
                ;;
            *)
                path="$1"
                shift
                ;;
        esac
    done

    # If no path is specified, use the current directory
    if [[ -z "$path" ]]; then
        path="."
    fi

    # Get the Git root directory and either change to it or print it
    local dir="$(cd "$path" && git rev-parse --show-toplevel 2>/dev/null)"
    if [[ -n "$dir" ]]; then
        dir="$(echo "$dir" | tr -d '\n')"
        if [[ -n "$show" ]]; then
            echo "$dir"
        else
            cd "$dir" || return
        fi
    else
        echo "Not inside a Git repository" >&2
        return 1
    fi
}

# print random human-friendly name
function namegen {
    jsCode=$(cat <<-ENDJS
        const {
            uniqueNamesGenerator,
            adjectives,
            colors,
            animals
        } = require('unique-names-generator');

        const output = uniqueNamesGenerator({
            dictionaries: [adjectives, colors, animals],
            separator: '-'
        });

        console.log(output);
ENDJS
)
    node -e "$jsCode"

    # npm package - https://www.npmjs.com/package/unique-names-generator#user-content-usage
    # multiline bash - "here document" (chatGPT) - https://chat.openai.com/chat/21ad89f6-231f-4f92-8256-52c0f652fdcb
    # node -e "some js code" option is available
}

function slow() {
    # default waiting time
    wait_time=0.5
    if [ "$1" -lt 5 ]; then
        wait_time="$1"
        return
    fi
    # if [ "$2" != '' ]; then
    #     $wait_time=$2
    # fi

    # do the work using awk
    "$@" | awk '{system("sleep '$wait_time'");print}'
}

function youtube-dl-numbered() {
    # runs the alias
    youtube-dl -cio "%(playlist_index)02d: %(title)s.%(ext)s" --write-sub --write-auto-sub --sub-lang en --embed-subs "$@"
}

function reposize() {
    # https://webapps.stackexchange.com/questions/39587/view-estimated-size-of-github-repository-before-cloning
    printf "$1" | perl -ne 'print $1 if m!([^/]+/[^/]+?)(?:\.git)?$!' | xargs -i curl -s -k https://api.github.com/repos/'{}' | grep size | tr -d -c 0-9 | awk '{printf $1/1024}'
    echo " MB"
}

#advanced grep - works for images and pdfs too
function advgrep() {
    grep "$1" -ri -I # text files
    pdfgrep "$1" -ri # PDFs

    # images
    GRAY='\033[1;32m'
    NC='\033[0m' # No Color
    for file in $(find . -name '*.*g'); do
        tesseract "$file" stdout 2>/dev/null | grep "$1" -i && echo -e "${GRAY}$file${NC}\n"
    done
}

function custom_prompt()
{
    export GIT_PS1_SHOWDIRTYSTATE=1
    PS1='%B%F{green}sanjar%f%b$%F{red} %c%f '

    # if [[ "${USERNAME}" == "muhammadsanjar"]] then
    #     PS1='%B%F{green}sanjar%f%b$%F{red}%~%f '
    # else
    #     # use $USERNAME
    #     PS1='%B%F{green}%n%f%b$%F{red}%~%f '
    # fi
}

# gitify prompt, taken from the Udacity Git course
function gitify_prompt() {
    red="\[\033[38;5;203m\]"
    green="\[\033[38;05;38m\]"
    blue="\[\033[0;34m\]"
    reset="\[\033[0m\]"

    export GIT_PS1_SHOWDIRTYSTATE=1

    # '\u' adds the name of the current user to the prompt
    # '\$(__git_ps1)' adds git-related stuff
    # '\W' adds the name of the current directory
    export PS1="$red\u$green\ $(__git_ps1)$blue \W
$ $reset"

    # Changes colors for tty consoles
    if [ "$TERM" = "xterm-256color" ]; then
        echo -en "\e]P0232323" #black
        echo -en "\e]P82B2B2B" #darkgrey
        echo -en "\e]P1D75F5F" #darkred
        echo -en "\e]P9E33636" #red
        echo -en "\e]P287AF5F" #darkgreen
        echo -en "\e]PA98E34D" #green
        echo -en "\e]P3D7AF87" #brown
        echo -en "\e]PBFFD75F" #yellow
        echo -en "\e]P48787AF" #darkblue
        echo -en "\e]PC7373C9" #blue
        echo -en "\e]P5BD53A5" #darkmagenta
        echo -en "\e]PDD633B2" #magenta
        echo -en "\e]P65FAFAF" #darkcyan
        echo -en "\e]PE44C9C9" #cyan
        echo -en "\e]P7E5E5E5" #lightgrey
        echo -en "\e]PFFFFFFF" #white
        clear                  #for background artifacting
    fi
}

# To use the Heroku CLI's autocomplete --
#   Via homebrew's shell completion:
#     1) Follow homebrew's install instructions https://docs.brew.sh/Shell-Completion
#         NOTE: For zsh, as the instructions mention, be sure compinit is autoloaded
#               and called, either explicitly or via a framework like oh-my-zsh.
#     2) Then run
#       $ heroku autocomplete --refresh-cache
#   OR
#   Use our standalone setup:
#     1) Run and follow the install steps:
#       $ heroku autocomplete

# CLI clipboard copy, paste
# Usage: `someCommand | c` copies the output to the clipboard
# Examples: `ls | c`, `cat someFile.txt | c`, `cat someFile.txt | grep 'hello' | c`
function copyAndPaste() {
    if command -v xclip &> /dev/null
    then
        alias c="xclip -selection clipboard"
        alias v="xclip -o -selection clipboard"
        # echo "xclip exists"
        return
    fi

    if command -v pbcopy &> /dev/null
    then
        alias c="cat | pbcopy"
        alias p="pbpaste"
        # echo "pbcopy exists"
        return
    fi
}

# kill process at port
# Usage:
# `portkill 3000`
# `portkill 8301 8302` (multiple arguments supported)
portkill() {
    for port in "$@"; do
        pids=$(lsof -ti tcp:"$port")
        if [ -n "$pids" ]; then
            echo "Killing process using port $port"
            echo "$pids" | xargs kill
        else
            echo "No processes found using port $port."
        fi
    done
}

# print total number of lines in files at path and all descendants
function countLines() {
    find "$1" -type f -exec wc -l {} + | awk '{total += $1} END{print total}'
}

## bookmark setup for paths, START
## https://github.com/sanjar-notes/swe-culture-n-tools/issues/12
## source: https://jeroenjanssens.com/navigate/
export MARKPATH=$HOME/.marks
function jump {
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}
function mark {
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}
function unmark {
    rm -i "$MARKPATH/$1"
}
function marks {
    \ls -l "$MARKPATH" | tail -n +2 | sed 's/  / /g' | cut -d' ' -f9- | awk -F ' -> ' '{printf "%-10s -> %s\n", $1, $2}'
}
function getmark {
    echo $(realpath "$MARKPATH/$1") || echo "No such mark: $1"
}
function remark {
    unmark "$1"
    mark "$1"
}

function _completemarks {
  reply=($(ls $MARKPATH))
}

compctl -K _completemarks jump
compctl -K _completemarks unmark
compctl -K _completemarks remark
compctl -K _completemarks getmark

# make shorter aliases for these
alias jp="jump"
alias mk="mark"
alias um="unmark"
alias mks="marks"
alias gm="getmark"

## bookmark setup END

# import function (run all top level files at path)
run_files_in_dir() {
    local directory="$1"

    if [ -d "$directory" ]; then
        for file in "$directory"/*.sh; do
            [ -e "$file" ] && source "$file"
        done
    else
        # commented out - remains silent
        # echo "Error: Directory not found - $directory"
        :
    fi
}

urlencode() {
    local l=${#1}
    for (( i = 0 ; i < l ; i++ )); do
        local c=${1:i:1}
        case "$c" in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            ' ') printf + ;;
            *) printf '%%%.2X' "'$c"
        esac
    done
}

urldecode() {
    local data=${1//+/ }
    printf '%b' "${data//%/\x}"
}

obsidian() {
    value_git_based_name=$(basename $(cd $1; git root))
    value_current_dir_based_name=$(basename "$(realpath $1)")
    vault_value=$([[ "$value_git_based_name" == "" ]] && echo $value_git_based_name || echo $value_current_dir_based_name)
    file_part=$([[ -z "$2" ]] && echo "" || "&file=$(urlencode $2)")
    open "obsidian://open?vault=$vault_value$file_part" # >/dev/null 2>&1 & #doesn't need it
}

# safely add my scripts, for home-controller
run_files_in_dir ~/.my-scripts /dev/null 2>&1
$(startShutdownServerIdempotent > /dev/null 2>&1 &)
